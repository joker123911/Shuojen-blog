<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆèªäº¤å‰å°‹å¯¶ - å®Œæ•´ç‰ˆ</title>
    <style>
        :root { --bg: #fdf5e6; --primary: #8b4513; --highlight: #fff3cd; --border: #f39c12; --key: #e74c3c; --locked-bg: #f0f0f0; --locked-text: #bbb; }
        body { font-family: sans-serif; background: var(--bg); display: flex; flex-direction: column; align-items: center; padding: 20px; }
        
        /* ç®¡ç†å€ï¼ˆæŒ‰éˆ•èˆ‡ä¸‹æ‹‰é¸å–®ï¼‰ */
        .top-bar { display: flex; gap: 10px; margin-bottom: 20px; align-items: center; }
        .btn { padding: 8px 16px; font-size: 14px; cursor: pointer; background: var(--primary); color: white; border: none; border-radius: 4px; transition: 0.2s; }
        .btn:hover { opacity: 0.9; }
        select { font-size: 14px; padding: 7px 10px; cursor: pointer; border: 1px solid var(--primary); border-radius: 4px; }

        /* éŠæˆ²èªªæ˜å½ˆçª— */
        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100; justify-content: center; align-items: center; }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 12px; max-width: 450px; border: 4px solid var(--primary); position: relative; line-height: 1.8; }
        .modal-content h3 { margin-top: 0; color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px; }
        .modal-content ol { padding-left: 20px; color: #444; }
        .close-btn { position: absolute; top: 10px; right: 15px; font-size: 24px; cursor: pointer; color: var(--primary); font-weight: bold; }

        /* éŠæˆ²ä¸»é«” */
        .game-wrapper { position: relative; padding: 5px; background: #444; border: 4px solid var(--primary); border-radius: 4px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .grid { display: grid; grid-template-columns: repeat(12, 40px); gap: 2px; }
        .cell { width: 40px; height: 40px; background: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: bold; cursor: pointer; user-select: none; position: relative; z-index: 1; transition: all 0.2s; }
        
        .cell.selected { background: var(--highlight); box-shadow: inset 0 0 0 2px var(--border); }
        .cell.locked:not(.is-key) { background: var(--locked-bg) !important; color: var(--locked-text) !important; cursor: default; box-shadow: none !important; }
        .cell.is-key { cursor: grab; z-index: 5; background: white !important; color: var(--primary) !important; box-shadow: 0 0 10px rgba(0,0,0,0.2) !important; }
        .cell.is-key::after { 
            content: ''; position: absolute; width: 34px; height: 34px; 
            border: 3px solid var(--key); border-radius: 50%; z-index: 2; 
            pointer-events: none; animation: pulse 1s infinite; 
        }
        @keyframes pulse { 0% { transform: scale(0.9); opacity: 0.7; } 50% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(0.9); opacity: 0.7; } }

        #svg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3; }
        .red-line { stroke: rgba(231, 76, 60, 0.6); stroke-width: 6; stroke-linecap: round; }
        .black-line { stroke: rgba(0, 0, 0, 0.8); stroke-width: 6; stroke-linecap: round; }

        .answer-section { margin-top: 40px; text-align: center; }
        .slots { display: flex; gap: 10px; margin-top: 15px; justify-content: center; }
        .slot { width: 55px; height: 55px; border: 2px solid var(--primary); background: #fff; display: flex; justify-content: center; align-items: center; font-size: 26px; font-weight: bold; border-radius: 8px; cursor: pointer; color: #d35400; transition: background 0.2s; }
        .slot:empty { cursor: default; background: rgba(255,255,255,0.5); border-style: dashed; }
        .slot.drag-over { background: #eee; border-color: var(--key); }
        
        #win-msg { display: none; margin-top: 25px; color: #27ae60; font-size: 24px; font-weight: bold; }
    </style>
</head>
<body ondragover="event.preventDefault()">

    <div class="top-bar">
        <button class="btn" onclick="toggleModal(true)">éŠæˆ²èªªæ˜</button>
        <select id="level-select" onchange="loadLevel(this.value)"></select>
    </div>

    <div id="info-modal" class="modal" onclick="toggleModal(false)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <span class="close-btn" onclick="toggleModal(false)">&times;</span>
            <h3>ğŸ“œ éŠæˆ²è¦å‰‡èªªæ˜</h3>
            <ol>
                <li>è¡¨æ ¼ä¸­è—æœ‰æ•¸å€‹å››å­—æˆèªï¼Œæ’åˆ—é †åºå¯èƒ½æ˜¯ç”±ä¸Šè€Œä¸‹ï¼Œç”±å·¦è€Œå³ã€ç”±å³è€Œå·¦ï¼Œæˆ–æ˜¯å‘ˆå°è§’ç·šï¼Œè«‹å…ˆæ‰¾å‡ºè¡¨æ ¼è£¡çš„æˆèªã€‚</li>
                <li>æ¯å…©å€‹æˆèªçš„äº¤å‰è™•å¯å¾—åˆ°ä¸€å€‹é—œéµå­—ã€‚é—œéµå­—æœ‰å¯èƒ½æœƒé‡è¤‡ã€‚</li>
                <li>æ‰¾åˆ°çš„é—œéµå­—å¯çµ„æˆä¸€å€‹ä¿šèªï¼Œå³ç‚ºæœ€å¾Œç­”æ¡ˆã€‚</li>
                <li><b>é¸å­—åé»ƒ</b>ï¼šé»æ“Šæ ¼å­é€²è¡Œåé»ƒé¸å–ï¼Œç•¶é€£ç·š<b>å‰›å¥½çµ„æˆå››å­—ç›´ç·š</b>æ™‚ï¼Œæœƒå‡ºç¾ç´…ç·šæç¤ºã€‚</li>
                <li><b>åœˆé¸é—œéµå­—</b>ï¼šèˆ‡å¦ä¸€æ¢å››å­—ç´…ç·š<b>äº¤å‰</b>å¾Œï¼Œé»æ“Šè©²äº¤é»ã€‚è‹¥è©²å­—å±¬æ–¼ç­”æ¡ˆæ–‡å­—ï¼Œå°‡æœƒå‡ºç¾<b>å‘¼å¸ç‡ˆç´…åœˆ</b>ã€‚</li>
                <li><b>é–å®šæˆèª</b>ï¼šé—œéµå­—åœˆé¸å¾Œï¼Œè©²æˆèªè·¯å¾‘æœƒè®Šç‚º<b>é»‘ç·šä¸¦æ·¡åŒ–èƒŒæ™¯</b>ã€‚é–å®šå¾Œçš„æ ¼å­ä¸å†åƒèˆ‡å…¶ä»–é€£ç·šåˆ¤æ–·ã€‚</li>
                <li><b>å‹•æ…‹æª¢æŸ¥</b>ï¼šè‹¥å–æ¶ˆé¸å–çš„æ ¼å­å°è‡´é€£ç·šä¸è¶³å››å­—ï¼Œå°æ‡‰çš„ç·šæ¢èˆ‡åœˆé¸ç‹€æ…‹å°‡æœƒè‡ªå‹•é€€å›ã€‚</li>
                <li><b>æ‹¼æ¹Šç­”æ¡ˆ</b>ï¼šå°‡åœˆé¸å‡ºçš„æ–‡å­—<b>æ‹–æ›³</b>åˆ°ä¸‹æ–¹ç©ºæ ¼ï¼Œæ‹¼å‡ºæ­£ç¢ºæˆèªå³å¯ç²å‹ã€‚</li>
            </ol>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" onclick="toggleModal(false)">é–‹å§‹éŠæˆ²</button>
            </div>
        </div>
    </div>
    
    <div class="game-wrapper">
        <div class="grid" id="grid"></div>
        <svg id="svg-overlay"></svg>
    </div>

    <div class="answer-section">
        <div class="slots" id="slots"></div>
        <div id="win-msg">ğŸ‰ æ­å–œå®Œæˆï¼</div>
    </div>

    <script>
        // --- å¿«é€Ÿå‡ºé¡Œå€ ---
        const puzzles = [
            {
                id: "001",
                grid: "æƒ…æ©Ÿå°‘å…¶æ™‚å¤ªç©ºåŸä¸­æ˜¯åƒ¹é–€å‹¤äº‹æ´›èª²å¸¸éè¡Œæ‡·æ¦®è“‹ç„¡æ‰¹æœ—é³¥åœ¨é™½éæƒ³å…ˆè¯ç«¹å¤ªä¹‹å ±åŠç™¼æœˆäººç´™å…¥å¯Œå¾…è¯åŒ—ä¿è…¦å¯†æ‰æ™‚æ˜ç‚ºè²´äººä¹‹é›†ç‹æ–‡ç‡äººå¸¶ä¸ä¸»æ˜Ÿæ¥å¤ç•¶åŠç­é–€åœ°å¤§æƒ³è²»è§£ç‰©ç¨€å‹™ç‰©å¤§ç„¡å¼„åºœå› å¡å¸æ–°ä¹‹æ›ä»¥æ­£åœ°è²´èº«æ›¿å ±æŠ±å°å¹´å¤šé¡æ˜Ÿè²Œå’ªæµ·åˆ†ç´°æœä¹‹å®¶ç²èšåŒ–é€¢ç§»å–å€ç¾©å‰›å™¨è€Œèˆ‡å‘å¤©å‰å…‡ä¸Šç¢¼äººæœ¨è¨¥å¤§æ™šæˆäººä¹‹æ¯å¤©æ™šåˆ†åˆ†æŠ˜å’Œ",
                answer: "ç‰©ä»¥ç¨€ç‚ºè²´"
            }
        ];

        const gridEl = document.getElementById('grid');
        const svgEl = document.getElementById('svg-overlay');
        const slotsEl = document.getElementById('slots');
        const levelSelect = document.getElementById('level-select');
        const size = 12;

        let selectedIndices = new Set(); 
        let manualKeys = new Map(); 
        let lockedCells = new Set(); 

        function toggleModal(show) {
            document.getElementById('info-modal').style.display = show ? 'flex' : 'none';
        }

        function setupLevelSelect() {
            puzzles.forEach((p, index) => {
                const opt = document.createElement('option');
                opt.value = index;
                opt.textContent = `ç¬¬ ${p.id} é—œ`;
                levelSelect.appendChild(opt);
            });
            loadLevel(0);
        }

        function loadLevel(index) {
            const p = puzzles[index];
            selectedIndices.clear();
            manualKeys.clear();
            lockedCells.clear();
            document.getElementById('win-msg').style.display = 'none';
            initBoard(p);
            updateVisuals();
        }

        function initBoard(puzzle) {
            gridEl.innerHTML = '';
            slotsEl.innerHTML = '';
            puzzle.grid.split('').forEach((char, i) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.textContent = char;
                cell.dataset.idx = i;
                cell.onclick = () => handleCellClick(i, cell);
                cell.draggable = false;
                cell.ondragstart = (e) => {
                    if (!cell.classList.contains('is-key')) return e.preventDefault();
                    e.dataTransfer.setData('text', cell.textContent);
                    e.dataTransfer.setData('sourceType', 'grid');
                };
                gridEl.appendChild(cell);
            });

            puzzle.answer.split('').forEach((_, i) => {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.draggable = true;
                slot.onclick = () => { slot.textContent = ""; checkWin(); };
                slot.ondragstart = (e) => {
                    if (!slot.textContent) return e.preventDefault();
                    e.dataTransfer.setData('text', slot.textContent);
                    e.dataTransfer.setData('sourceType', 'slot');
                    e.dataTransfer.setData('sourceIdx', i);
                };
                slot.ondragover = e => { e.preventDefault(); slot.classList.add('drag-over'); };
                slot.ondragleave = () => slot.classList.remove('drag-over');
                slot.ondrop = handleSlotDrop;
                slotsEl.appendChild(slot);
            });
        }

        function handleCellClick(idx, el) {
            if (lockedCells.has(idx) && !manualKeys.has(idx)) return;
            if (manualKeys.has(idx)) {
                const lines = manualKeys.get(idx);
                lines.forEach(line => line.forEach(id => {
                    lockedCells.delete(id);
                    selectedIndices.add(id);
                }));
                manualKeys.delete(idx);
            } else if (selectedIndices.has(idx)) {
                const junctionLines = get4CharLines(idx, selectedIndices);
                const isAnswerChar = puzzles[levelSelect.value].answer.includes(el.textContent);
                if (junctionLines.length >= 2 && isAnswerChar) {
                    manualKeys.set(idx, junctionLines);
                    junctionLines.forEach(line => line.forEach(id => {
                        lockedCells.add(id);
                        selectedIndices.delete(id);
                    }));
                } else {
                    selectedIndices.delete(idx);
                }
            } else {
                selectedIndices.add(idx);
            }
            updateVisuals();
        }

        function updateVisuals() {
            svgEl.innerHTML = '';
            const cells = Array.from(gridEl.children);
            cells.forEach((c, i) => {
                c.classList.toggle('selected', selectedIndices.has(i));
                c.classList.toggle('locked', lockedCells.has(i));
                c.classList.remove('is-key');
                c.draggable = false;
            });
            findAll4CharLines(selectedIndices).forEach(line => {
                const ends = getEnds(line);
                drawSvgLine(ends.start, ends.end, 'red-line');
            });
            manualKeys.forEach((lines, keyIdx) => {
                cells[keyIdx].classList.add('is-key');
                cells[keyIdx].draggable = true;
                lines.forEach(line => {
                    const ends = getEnds(line);
                    drawSvgLine(ends.start, ends.end, 'black-line');
                });
            });
        }

        function get4CharLines(idx, set) {
            const lines = [];
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            const r = Math.floor(idx / size), c = idx % size;
            dirs.forEach(([dr, dc]) => {
                let path = [idx];
                [[dr, dc], [-dr, -dc]].forEach(([tr, tc]) => {
                    for (let k = 1; k < size; k++) {
                        const nr = r + tr*k, nc = c + tc*k;
                        const nIdx = nr * size + nc;
                        if (nr>=0 && nr<size && nc>=0 && nc<size && set.has(nIdx)) path.push(nIdx); else break;
                    }
                });
                if (path.length === 4) lines.push(path);
            });
            return lines;
        }

        function findAll4CharLines(set) {
            const paths = [];
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            const checked = new Set();
            set.forEach(idx => {
                dirs.forEach(([dr, dc]) => {
                    const k = `${idx}-${dr}-${dc}`;
                    if (checked.has(k)) return;
                    let path = [idx];
                    [[dr, dc], [-dr, -dc]].forEach(([tr, tc]) => {
                        for (let k = 1; k < size; k++) {
                            const nr = Math.floor(idx/size) + tr*k, nc = (idx%size) + tc*k;
                            const nIdx = nr*size + nc;
                            if (nr>=0 && nr<size && nc>=0 && nc<size && set.has(nIdx)) {
                                path.push(nIdx);
                                checked.add(`${nIdx}-${dr}-${dc}`);
                                checked.add(`${nIdx}-${-dr}-${-dc}`);
                            } else break;
                        }
                    });
                    if (path.length === 4) paths.push(path);
                });
            });
            return paths;
        }

        function getEnds(path) {
            let start = path[0], end = path[0];
            path.forEach(i => {
                const r = Math.floor(i/12), c = i%12;
                const sr = Math.floor(start/12), sc = start%12;
                const er = Math.floor(end/12), ec = end%12;
                if (r < sr || (r === sr && c < sc)) start = i;
                if (r > er || (r === er && c > ec)) end = i;
            });
            return { start, end };
        }

        function drawSvgLine(sIdx, eIdx, cls) {
            const s = gridEl.children[sIdx], e = gridEl.children[eIdx];
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", s.offsetLeft + 20); line.setAttribute("y1", s.offsetTop + 20);
            line.setAttribute("x2", e.offsetLeft + 20); line.setAttribute("y2", e.offsetTop + 20);
            line.setAttribute("class", cls);
            svgEl.appendChild(line);
        }

        function handleSlotDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            const char = e.dataTransfer.getData('text');
            const sourceType = e.dataTransfer.getData('sourceType');
            if (sourceType === 'grid') {
                this.textContent = char;
            } else {
                const sIdx = e.dataTransfer.getData('sourceIdx');
                const sSlot = document.querySelectorAll('.slot')[sIdx];
                const temp = this.textContent;
                this.textContent = char;
                sSlot.textContent = temp;
            }
            checkWin();
        }

        function checkWin() {
            const current = Array.from(document.querySelectorAll('.slot')).map(s => s.textContent).join('');
            document.getElementById('win-msg').style.display = (current === puzzles[levelSelect.value].answer) ? 'block' : 'none';
        }

        setupLevelSelect();
    </script>
</body>
</html>