<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æˆèªè¿·å®®</title>
    <script src="puzzle.js"></script>
    <script src="dictionary.js"></script>
    <style>
        :root { --bg: #fdf5e6; --primary: #8b4513; --highlight: #fff3cd; --border: #f39c12; --key: #e74c3c; --locked-bg: #f0f0f0; --locked-text: #bbb; }
        body { font-family: sans-serif; background: var(--bg); display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        
        .top-bar { display: flex; gap: 10px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; justify-content: center; }
        .btn { padding: 8px 16px; font-size: 14px; cursor: pointer; background: var(--primary); color: white; border: none; border-radius: 4px; transition: 0.2s; }
        .btn:hover { opacity: 0.9; }
        select { font-size: 14px; padding: 7px 10px; cursor: pointer; border: 1px solid var(--primary); border-radius: 4px; }

        .modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100; justify-content: center; align-items: center; }
        .modal-content { background: var(--bg); padding: 30px; border-radius: 12px; max-width: 450px; width: 90%; border: 4px solid var(--primary); position: relative; line-height: 1.8; overflow-y: auto; max-height: 90vh; }
        .modal-content h3 { margin-top: 0; color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px; }
        .modal-content ol { padding-left: 20px; color: #444; }
        .close-btn { position: absolute; top: 10px; right: 15px; font-size: 24px; cursor: pointer; color: var(--primary); font-weight: bold; }

        /* ç°¡æ½”å¤–æ¡†è¨­è¨ˆ - ä¿®æ”¹ï¼špadding æ”¹ç‚º 3px ä»¥åŒ¹é…å…§éƒ¨æ ¼ç·š */
        .game-wrapper { position: relative; padding: 3px; background: #fff; border: 2px solid var(--primary); border-radius: 8px; width: 100%; max-width: 490px; }
        /* æ ¼ç·šèƒŒæ™¯è‰² - ä¿®æ”¹ï¼šgap æ”¹ç‚º 3px è®“æ ¼ç·šè®Šç²— */
        .grid { display: grid; grid-template-columns: repeat(12, 1fr); gap: 3px; background: #999; }
        .cell { aspect-ratio: 1 / 1; background: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: bold; cursor: pointer; user-select: none; position: relative; z-index: 1; transition: all 0.2s; }
        
        @media (max-width: 450px) { .cell { font-size: 4vw; } }

        .cell.selected { background: var(--highlight); box-shadow: inset 0 0 0 2px var(--border); }
        
        /* é–å®šæ ¼å­çš„æ¨£å¼ */
        .cell.locked:not(.is-key) {
            background: var(--locked-bg) !important;
            color: var(--locked-text) !important;
            cursor: default;
        }

        .cell.is-key { cursor: grab; z-index: 5; background: white !important; color: var(--primary) !important; }
        
        /* ç´…åœˆåœˆæ¨£å¼ */
        .cell.is-key::after { 
            content: ''; position: absolute;
            width: 88%; height: 88%; 
            border: 4px solid var(--key); 
            border-radius: 50%; z-index: 2; 
            pointer-events: none; animation: pulse 1s infinite; 
        }
        
        /* é¸ä¸­ç‹€æ…‹è®Šç´… */
        .cell.is-key.active-key { background: #ffdad6 !important; outline: 2px solid var(--key); z-index: 6; }

        @keyframes pulse { 0% { transform: scale(0.9); opacity: 0.7; } 50% { transform: scale(1.1); opacity: 1; } 100% { transform: scale(0.9); opacity: 0.7; } }

        #svg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3; }
        .red-line { stroke: rgba(231, 76, 60, 0.6); stroke-width: 6; stroke-linecap: round; }
        .black-line { stroke: rgba(0, 0, 0, 0.8); stroke-width: 6; stroke-linecap: round; }

        .answer-section { margin-top: 40px; text-align: center; width: 100%; }
        .slots { display: flex; gap: 10px; margin-top: 15px; justify-content: center; flex-wrap: wrap; }
        .slot { width: 55px; height: 55px; border: 2px solid var(--primary); background: #fff; display: flex; justify-content: center; align-items: center; font-size: 26px; font-weight: bold; border-radius: 8px; cursor: pointer; color: #d35400; transition: background 0.2s; }
        .slot:empty { cursor: default; background: rgba(255,255,255,0.5); border-style: dashed; }
        .slot.drag-over { background: #eee; border-color: var(--key); }
        
        #win-msg { display: none; margin-top: 25px; color: #27ae60; font-size: 24px; font-weight: bold; }
        
        .badge { padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
        .bg-yellow { background: var(--highlight); }
        .bg-red-circle { display: inline-block; width: 18px; height: 18px; border: 2px solid var(--key); border-radius: 50%; vertical-align: middle; }
    </style>
</head>
<body ondragover="event.preventDefault()">

    <div class="top-bar">
        <button class="btn" onclick="toggleModal(true)">éŠæˆ²èªªæ˜</button>
        <select id="level-select" onchange="loadLevel(this.value)"></select>
    </div>

    <div id="info-modal" class="modal" onclick="toggleModal(false)">
        <div class="modal-content" onclick="event.stopPropagation()">
            <span class="close-btn" onclick="toggleModal(false)">&times;</span>
            <h3>ğŸ“œ éŠæˆ²è¦å‰‡èªªæ˜</h3>
                <ul>
                    <li data-num="1.">è¡¨æ ¼ä¸­è—æœ‰æ•¸å€‹å››å­—æˆèªï¼Œæ’åˆ—é †åºå¯èƒ½æ˜¯ç”±ä¸Šè€Œä¸‹ã€ç”±å·¦è€Œå³ã€ç”±å³è€Œå·¦ï¼Œæˆ–æ˜¯å‘ˆå°è§’ç·šï¼Œè«‹å…ˆæ‰¾å‡ºè¡¨æ ¼è£¡çš„æˆèªã€‚</li>
                    <li data-num="2.">æ¯å…©å€‹æˆèªçš„äº¤å‰è™•å¯å¾—åˆ°ä¸€å€‹é—œéµå­—ã€‚é—œéµå­—æœ‰å¯èƒ½æœƒé‡è¤‡ã€‚</li>
                    <li data-num="3.">æ‰¾åˆ°çš„é—œéµå­—å¯çµ„æˆä¸€å€‹ä¿šèªï¼Œå³ç‚ºæœ€å¾Œç­”æ¡ˆã€‚</li>
                </ul>

                <h4>æ“ä½œæç¤º</h4>
                <ul class="rule-list">
                    <li data-num="â—†">é»æ“Šæ–‡å­—é€²è¡Œ<span class="badge bg-yellow">åé»ƒ</span>é¸å–ï¼Œé€£ç·š<b>å‰›å¥½</b>å››å­—æœƒå‡ºç¾è¼”åŠ©ç´…ç·šï¼ˆä¸èƒ½è¶…éï¼‰ã€‚</li>
                    <li data-num="â—†">èˆ‡å¦ä¸€æ¢ç´…ç·šäº¤å‰å¾Œï¼Œé»æ“Š<b>äº¤å‰è™•</b>å¯åœˆé¸é—œéµå­—<span class="bg-red-circle"></span>ã€‚</li>
                    <li data-num="â—†">åœˆé¸å¾Œï¼Œè‹¥æ­£ç¢ºï¼Œæˆèªæœƒé–å®šè®Šç‚º<b>é»‘ç·šä¸¦æ·¡åŒ–</b>ã€‚</li>
                    <li data-num="â—†"><b>é—œéµå­—æ“ä½œ</b>ï¼šé»æ“Šä¸€ä¸‹è®Šç´…å¯å¡«å…¥ç©ºæ ¼ï¼›è‹¥é¸éŒ¯äº†ï¼Œ<b>å†é»ä¸€ä¸‹è®Šç´…çš„å­—</b>å³å¯å–æ¶ˆåœˆé¸ä¸¦è§£é–æˆèªã€‚</li>
                    <li data-num="â—†">å°‡é—œéµå­—<b>æ‹–æ›³æˆ–é»é¸</b>è‡³ä¸‹æ–¹ç©ºæ ¼ï¼Œæ‹¼å‡ºæ­£ç¢ºä¿šèªå³å¯ç²å‹ã€‚</li>
                </ul>
            <div style="text-align: center; margin-top: 20px;">
                <button class="btn" onclick="toggleModal(false)">é–‹å§‹éŠæˆ²</button>
            </div>
        </div>
    </div>
    
    <div class="game-wrapper">
        <div class="grid" id="grid"></div>
        <svg id="svg-overlay"></svg>
    </div>

    <div class="answer-section">
        <div class="slots" id="slots"></div>
        <div id="win-msg">ğŸ‰ æ­£ç¢ºç­”æ¡ˆï¼Œæ­å–œï¼</div>
    </div>

    <script>
        const gridEl = document.getElementById('grid');
        const svgEl = document.getElementById('svg-overlay');
        const slotsEl = document.getElementById('slots');
        const levelSelect = document.getElementById('level-select');
        const size = 12;

        let selectedIndices = new Set(); 
        let manualKeys = new Map(); 
        let lockedCells = new Set(); 
        let mobileSelectedChar = null; 
        let activeKeyIdx = null; 

        function toggleModal(show) {
            document.getElementById('info-modal').style.display = show ? 'flex' : 'none';
        }

        function setupLevelSelect() {
            if (typeof puzzles === 'undefined') {
                alert("æ‰¾ä¸åˆ°é¡Œç›®æª” (puzzle.js)ï¼Œè«‹ç¢ºèªæª”æ¡ˆè·¯å¾‘æ˜¯å¦æ­£ç¢ºã€‚");
                return;
            }
            puzzles.forEach((p, index) => {
                const opt = document.createElement('option');
                opt.value = index;
                opt.textContent = `ç¬¬ ${p.id} é—œ`;
                levelSelect.appendChild(opt);
            });
            loadLevel(0);
        }

        function loadLevel(index) {
            const p = puzzles[index];
            selectedIndices.clear();
            manualKeys.clear();
            lockedCells.clear();
            mobileSelectedChar = null;
            activeKeyIdx = null;
            document.getElementById('win-msg').style.display = 'none';
            initBoard(p);
            updateVisuals();
        }

        function initBoard(puzzle) {
            gridEl.innerHTML = '';
            slotsEl.innerHTML = '';
            puzzle.grid.split('').forEach((char, i) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.textContent = char;
                cell.dataset.idx = i;
                cell.onclick = () => handleCellClick(i, cell);
                cell.draggable = false;
                cell.ondragstart = (e) => {
                    if (!cell.classList.contains('is-key')) return e.preventDefault();
                    e.dataTransfer.setData('text', cell.textContent);
                    e.dataTransfer.setData('sourceType', 'grid');
                };
                gridEl.appendChild(cell);
            });

            puzzle.answer.split('').forEach((_, i) => {
                const slot = document.createElement('div');
                slot.className = 'slot';
                slot.draggable = true;
                slot.onclick = () => { 
                    if(mobileSelectedChar) {
                        slot.textContent = mobileSelectedChar;
                        mobileSelectedChar = null;
                        activeKeyIdx = null;
                        updateVisuals();
                    } else {
                        slot.textContent = ""; 
                    }
                    checkWin(); 
                };
                slot.ondragover = e => { e.preventDefault(); slot.classList.add('drag-over'); };
                slot.ondragleave = () => slot.classList.remove('drag-over');
                slot.ondrop = handleSlotDrop;
                slotsEl.appendChild(slot);
            });
        }

        function handleCellClick(idx, el) {
            if (lockedCells.has(idx) && !manualKeys.has(idx)) return;
            
            if (manualKeys.has(idx)) {
                if (activeKeyIdx === idx) {
                    const lines = manualKeys.get(idx);
                    lines.forEach(line => line.forEach(id => {
                        lockedCells.delete(id);
                        selectedIndices.add(id); 
                    }));
                    manualKeys.delete(idx);
                    mobileSelectedChar = null;
                    activeKeyIdx = null;
                } else {
                    mobileSelectedChar = el.textContent;
                    activeKeyIdx = idx;
                }
                updateVisuals();
                return;
            }

            if (selectedIndices.has(idx)) {
                const junctionLines = get4CharLines(idx, selectedIndices);
                const isAnswerChar = puzzles[levelSelect.value].answer.includes(el.textContent);
                if (junctionLines.length >= 2 && isAnswerChar) {
                    manualKeys.set(idx, junctionLines);
                    junctionLines.forEach(line => line.forEach(id => {
                        lockedCells.add(id);
                        selectedIndices.delete(id);
                    }));
                } else {
                    selectedIndices.delete(idx);
                }
            } else {
                selectedIndices.add(idx);
            }
            updateVisuals();
        }

        function updateVisuals() {
            svgEl.innerHTML = '';
            const cells = Array.from(gridEl.children);
            cells.forEach((c, i) => {
                c.classList.toggle('selected', selectedIndices.has(i));
                c.classList.toggle('locked', lockedCells.has(i));
                c.classList.remove('is-key', 'active-key');
                if (manualKeys.has(i)) {
                    c.classList.add('is-key');
                    c.draggable = true;
                    if (activeKeyIdx === i) c.classList.add('active-key');
                }
            });
            findAll4CharLines(selectedIndices).forEach(line => {
                const ends = getEnds(line);
                drawSvgLine(ends.start, ends.end, 'red-line');
            });
            manualKeys.forEach((lines, keyIdx) => {
                lines.forEach(line => {
                    const ends = getEnds(line);
                    drawSvgLine(ends.start, ends.end, 'black-line');
                });
            });
        }

        function get4CharLines(idx, set) {
            const lines = [];
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            const r = Math.floor(idx / size), c = idx % size;
            dirs.forEach(([dr, dc]) => {
                let path = [idx];
                [[dr, dc], [-dr, -dc]].forEach(([tr, tc]) => {
                    for (let k = 1; k < size; k++) {
                        const nr = r + tr*k, nc = c + tc*k;
                        const nIdx = nr * size + nc;
                        if (nr>=0 && nr<size && nc>=0 && nc<size && set.has(nIdx)) path.push(nIdx); else break;
                    }
                });
                if (path.length === 4) lines.push(path);
            });
            return lines;
        }

        function findAll4CharLines(set) {
            const paths = [];
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            const checked = new Set();
            set.forEach(idx => {
                dirs.forEach(([dr, dc]) => {
                    const k = `${idx}-${dr}-${dc}`;
                    if (checked.has(k)) return;
                    let path = [idx];
                    [[dr, dc], [-dr, -dc]].forEach(([tr, tc]) => {
                        for (let k = 1; k < size; k++) {
                            const nr = Math.floor(idx/size) + tr*k, nc = (idx%size) + tc*k;
                            const nIdx = nr*size + nc;
                            if (nr>=0 && nr<size && nc>=0 && nc<size && set.has(nIdx)) {
                                path.push(nIdx);
                                checked.add(`${nIdx}-${dr}-${dc}`);
                                checked.add(`${nIdx}-${-dr}-${-dc}`);
                            } else break;
                        }
                    });
                    if (path.length === 4) paths.push(path);
                });
            });
            return paths;
        }

        function getEnds(path) {
            let start = path[0], end = path[0];
            path.forEach(i => {
                const r = Math.floor(i/12), c = i%12;
                const sr = Math.floor(start/12), sc = start%12;
                const er = Math.floor(end/12), ec = end%12;
                if (r < sr || (r === sr && c < sc)) start = i;
                if (r > er || (r === er && c > ec)) end = i;
            });
            return { start, end };
        }

        function drawSvgLine(sIdx, eIdx, cls) {
            const s = gridEl.children[sIdx], e = gridEl.children[eIdx];
            if (!s || !e) return;
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            const offset = s.offsetWidth / 2;
            line.setAttribute("x1", s.offsetLeft + offset); line.setAttribute("y1", s.offsetTop + offset);
            line.setAttribute("x2", e.offsetLeft + offset); line.setAttribute("y2", e.offsetTop + offset);
            line.setAttribute("class", cls);
            svgEl.appendChild(line);
        }

        function handleSlotDrop(e) {
            e.preventDefault();
            this.classList.remove('drag-over');
            const char = e.dataTransfer.getData('text');
            this.textContent = char;
            checkWin();
        }

        function checkWin() {
            const current = Array.from(document.querySelectorAll('.slot')).map(s => s.textContent).join('');
            document.getElementById('win-msg').style.display = (current === puzzles[levelSelect.value].answer) ? 'block' : 'none';
        }

        window.addEventListener('resize', updateVisuals);
        setupLevelSelect();
    </script>
</body>
</html>